---
layout:         post
title:          Lambda
description:    Lambda表达式的用法
keywords: lambda predicate 
---

###**Lambda**
     
####**谓词**

> 谓词是一个可用的表达式，其返回结果是一个用做条件的值。标准算法库所使用的谓词分为两类：
  一元谓词(unary predicate,只接受单一参数)和二元谓词(binary predicate,有两个参数)。
   
####**lambda表达式**
  
> 当我们希望自定义的函数需要更多的参数，超出了算法对谓词的限制时。

   
######**介绍lambda**
       
> 我们可以向一个算法传递任何类别的可调用对象。对于一个对象或一个表达式，如果可以对其使用调用运算符，则称这个对象时可调用的。即，如果e是一个可调用的表达式，则我们可以写代码e(args),其中args是一个逗号分隔的一个或多个参数表达式。

> 可调用对象分别有:函数，函数指针，重载了函数调用运算符的类，以及lambda表达式。lambda表达式是介绍的重点.

> 一个lambda表达式表示一个可调用的代码单元。我们可将其理解为一个未命名的内联函数。

> 一个lambda表达式具有如下形式:

> [capture list]  (parameter list)->return type {function body}

>   + capture list:lambda所在函数中定义的局部变量的列表；
  + parameter list:参数列表;
  + return type: 返回类型;
  + function body:函数体。
       
> 注：我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体。
    如下所示：

> auto f=[]{return 42;};
       
> 果lambda的函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void。
       
     
######**向lambda传递参数**

> lambda不能有默认参数。一个lambda调用的实参数目永远与形参数目相等。 

> 一旦形参初始化完毕，就可以执行函数体。

> 例子:[](int a,int b){return a>b?a:b;};
        
######**使用捕获列表**

> 一个lambda通过将局部变量包含在其捕获列表中来指出将会使用这些变量.    捕获列表指引lambda再起内部包含访问访问局部变量所需的信息。

> 例子：[sz] (int a){return a>=sz;};

> 注：一个lambda只有在捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。
    
####**lambda捕获和返回**

> 当定义一个lambda时，编译器生成一个与lambda对应的新的(未命名)类类型。

> 捕获方式可以是值或引用。

######**值捕获**

> 与传递参数类似，采用值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量是在lambda创建时拷贝，而不是调用时拷贝。

>>  void fun()
    {
         int a=100;
         auto f=[a](int d){return a+b;};
         //...
    }

######**引用捕获**

>   void fun()
    {
         int a=100;
         auto f=[&a](int b){return a+b;};
         //...
    }

> **WARNING**:当我们以引用方式捕获一个变量时，必须保证在lambda执行时变量时存在的。
     
   
######**建议:尽量保持lambda的变量捕获简单化**

> 一个lambda捕获从lambda被创建到lambda自身执行这段时间内保存的相关信息。确保lambda每次执行的时候这些信息都是有预期的意义，是程序员的责任。

> 捕获一个普通变量，如int，string，或其他非指针的类型吗，通常可以采用简单的值捕获方式。在此情况下，只需关注变量在捕获时是否有我们需要的值就可以了。

> 如果我们捕获一个指针或者迭代器，或采用引用捕获方式，就必须确保在lambda执行时，绑定到迭代器、指针或者引用对象的存在。而且，需要保证对象具有预期的值。在lambda从创建到它执行的这段时间内,可能有代码改变绑定的对象的值。也就是说，在指针或引用被捕获时，绑定的对象的值是我们所期望的，但在lambda执行时，该对象的值可能已经完全不同。

> 一般来说，我们应该尽量减少捕获的数据量，来避免潜在的捕获导致的问题。
  而且，如果可能的话，应该避免捕捉指针或者引用.
    
######**隐式捕获**

> 在捕获列表中使用=或者&告诉编译器进行隐式捕获，其中=代表值捕获，&代表引用捕获。
  
>   当我们混合使用隐式捕获和显示捕获时，捕获列表中的第一个元素必须是一个&或者=。此符号指定了默认捕获方式为引用或值。

######**lambda捕获列表总结**

| 符号 | 描述 |
|:----:|:-----|
|[]|空捕获列表。lambda不能使用所在函数中的变量。一个lambda只有捕获变量后才能使用它们。|
|[names]|names是一个逗号分隔的名字列表，这些名字都是lambda所在函数的局部变量。默认情况下，捕获列表中的变量都**被拷贝**。名字前如果使用了**&**，则采用**引用**捕获方式。|
|[&]|隐式捕获列表，采用**引用捕获方式**，lambda体中所使用的来自所在函数的实体都采用引用方式使用|
|[=]|隐式捕获列表，采用**值捕获方式**。lambda体中将拷贝所使用的来自函数的实体的值。|
|[&,identifier_list]|identifier_list是一个逗号分隔的列表，包含0个或多个来自所在函数的变量。这些变量采用**值捕获方式**，而任何**隐式捕获**的变量都采用**引用方式捕获**。identifier_list中的名字前面**不能使用&**。|
|[=,identfier_list]|identifier_list 中的变量都采用**引用方式捕获**，而任何**隐式捕获**的变量都采用**值方式捕获**。identifier_list 中的名字不能包括this，且这些名字之前必须使用&|

######**可变lambda**

> 默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。

> 如果我们希望能改变一个被捕获的变量的值，就必须在参数列表之后加上mutable。因此，可变lambda可能省略参数列表：

>   void fun3()
    {
        int v1=42;
        auto f=[v1]()mutbale{return ++v1;};
        //...
    }

> 一个引用捕获的变量是否可以修改依赖于此引用指向的是一个const类型还是一个非const类型。

######**指定lambda返回类型**

> 默认情况下，如果一个lambda体包含return之外的任何语句，则编译器假定此lambda返回void。 

> 当有多个return语句时，我们必须使用尾置返回类型指定返回的类型。

> 例子:

> auto f=[](int i )->int {if(i>0)return i;else return -i;};